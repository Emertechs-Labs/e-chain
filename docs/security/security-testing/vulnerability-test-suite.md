# Comprehensive Vulnerability Test Suite

This document provides a complete testing framework for validating all security fixes and preventing regression of vulnerabilities.

## Testing Overview

### Test Categories
1. **Critical Vulnerability Tests** - Verify fixes for the 3 critical issues
2. **High-Risk Vulnerability Tests** - Validate high-risk issue resolutions
3. **Attack Vector Tests** - Simulate real-world attack scenarios
4. **Regression Tests** - Ensure fixes don't introduce new vulnerabilities
5. **Integration Security Tests** - Cross-contract security validation
6. **Performance Security Tests** - DoS and gas limit testing

## Test Framework Setup

### Required Tools
```bash
# Install testing dependencies
npm install --save-dev @foundry-rs/forge
npm install --save-dev echidna-test
npm install --save-dev slither-analyzer
npm install --save-dev mythx-cli

# Setup test environment
forge init test-security
cd test-security
```

### Test Configuration

```typescript
// hardhat.config.ts - Security test configuration
import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";

const config: HardhatUserConfig = {
  solidity: {
    version: "0.8.24",
    settings: {
      optimizer: {
        enabled: true,
        runs: 99999,
      },
    },
  },
  networks: {
    hardhat: {
      gas: 30000000,
      blockGasLimit: 30000000,
      allowUnlimitedContractSize: true,
    },
  },
  mocha: {
    timeout: 300000, // 5 minutes for complex security tests
  },
};

export default config;
```

## Critical Vulnerability Tests

### Test Suite 1: Clone Factory Race Condition

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../contracts/core/EventFactory.sol";
import "../contracts/core/EventTicket.sol";

contract CloneRaceConditionTest is Test {
    EventFactory factory;
    EventTicket template;
    address organizer = makeAddr("organizer");
    address attacker = makeAddr("attacker");
    address treasury = makeAddr("treasury");

    function setUp() public {
        template = new EventTicket();
        factory = new EventFactory(address(template), treasury);
        factory.verifyOrganizer(organizer);
        
        vm.deal(organizer, 100 ether);
        vm.deal(attacker, 100 ether);
    }

    function testCannotFrontRunInitialization() public {
        vm.startPrank(organizer);
        
        uint256 startTime = block.timestamp + 3600;
        uint256 endTime = startTime + 7200;
        
        // Record state before event creation
        uint256 eventCountBefore = factory.eventCount();
        
        // Create event - should be atomic with initialization
        uint256 eventId = factory.createEvent(
            "Test Event",
            "ipfs://test-metadata",
            0.1 ether,
            100,
            startTime,
            endTime
        );
        
        // Verify event was created
        assertEq(factory.eventCount(), eventCountBefore + 1);
        
        // Get the created ticket contract
        EventFactory.Event memory eventData = factory.getEvent(eventId);
        EventTicket ticketContract = EventTicket(eventData.ticketContract);
        
        // Verify contract is properly initialized
        assertTrue(ticketContract.isInitialized());
        assertEq(ticketContract.organizer(), organizer);
        assertEq(ticketContract.factory(), address(factory));
        assertEq(ticketContract.eventId(), eventId);
        
        vm.stopPrank();
        
        // Attacker cannot re-initialize
        vm.startPrank(attacker);
        vm.expectRevert("Already initialized");
        ticketContract.initialize(
            "Malicious Event",
            "EVIL",
            attacker,
            999,
            1 ether,
            1000,
            address(factory)
        );
        vm.stopPrank();
    }

    function testAddressPredictionAccuracy() public {
        vm.startPrank(organizer);
        
        uint256 timestamp = block.timestamp;
        uint256 blockNumber = block.number;
        
        // Predict address before creation
        address predictedAddress = factory.predictTicketContractAddress(
            organizer,
            1, // Next event ID
            timestamp,
            blockNumber
        );
        
        // Create event
        uint256 eventId = factory.createEvent(
            "Prediction Test",
            "ipfs://prediction-test",
            0.05 ether,
            50,
            block.timestamp + 3600,
            block.timestamp + 10800
        );
        
        // Verify prediction accuracy
        EventFactory.Event memory eventData = factory.getEvent(eventId);
        assertEq(eventData.ticketContract, predictedAddress);
        
        vm.stopPrank();
    }

    function testConcurrentEventCreation() public {
        // Test multiple events created in same block
        vm.startPrank(organizer);
        
        address[] memory predictedAddresses = new address[](3);
        uint256[] memory eventIds = new uint256[](3);
        
        // Predict addresses for batch creation
        for (uint256 i = 0; i < 3; i++) {
            predictedAddresses[i] = factory.predictTicketContractAddress(
                organizer,
                i + 1,
                block.timestamp,
                block.number
            );
        }
        
        // Create events in batch
        for (uint256 i = 0; i < 3; i++) {
            eventIds[i] = factory.createEvent(
                string(abi.encodePacked("Event ", vm.toString(i + 1))),
                string(abi.encodePacked("ipfs://event-", vm.toString(i + 1))),
                0.1 ether,
                100,
                block.timestamp + 3600,
                block.timestamp + 10800
            );
        }
        
        // Verify all predictions were correct
        for (uint256 i = 0; i < 3; i++) {
            EventFactory.Event memory eventData = factory.getEvent(eventIds[i]);
            assertEq(eventData.ticketContract, predictedAddresses[i]);
            
            EventTicket ticket = EventTicket(eventData.ticketContract);
            assertTrue(ticket.isInitialized());
            assertEq(ticket.organizer(), organizer);
        }
        
        vm.stopPrank();
    }

    function testInitializationWindowExpiry() public {
        // Deploy fresh template to test initialization window
        EventTicket freshTemplate = new EventTicket();
        
        // Advance blocks beyond initialization window
        vm.roll(block.number + 10);
        
        // Should fail to initialize after window expires
        vm.expectRevert("Initialization expired");
        freshTemplate.initialize(
            "Expired Init",
            "EXPIRED",
            organizer,
            1,
            0.1 ether,
            100,
            address(factory)
        );
    }

    function testEmergencyInitializationLock() public {
        EventTicket newTemplate = new EventTicket();
        
        // Owner can emergency lock initialization
        newTemplate.emergencyLockInitialization();
        
        // Should fail to initialize after emergency lock
        vm.expectRevert("Initialization window closed");
        newTemplate.initialize(
            "Locked Init",
            "LOCKED",
            organizer,
            1,
            0.1 ether,
            100,
            address(factory)
        );
    }
}
```

### Test Suite 2: Signature Replay Vulnerability

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../contracts/modules/POAPAttendance.sol";
import "../contracts/core/EventFactory.sol";

contract SignatureReplayTest is Test {
    POAPAttendance poap;
    EventFactory eventFactory;
    
    address signer = makeAddr("signer");
    address attendee = makeAddr("attendee");
    address attacker = makeAddr("attacker");
    
    uint256 signerPrivateKey = 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef;

    function setUp() public {
        // Deploy contracts
        eventFactory = new EventFactory(address(0x1), address(0x2));
        poap = new POAPAttendance(address(eventFactory));
        
        // Setup signer
        signer = vm.addr(signerPrivateKey);
        
        // Transfer ownership to signer for signature authorization
        poap.transferOwnership(signer);
    }

    function testSignatureReplayPrevention() public {
        uint256 eventId = 1;
        uint256 nonce = 0;
        uint256 deadline = block.timestamp + 1800; // 30 minutes
        
        // Generate EIP-712 signature
        bytes32 digest = poap.getSignatureData(eventId, attendee, nonce, deadline);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPrivateKey, digest);
        bytes memory signature = abi.encodePacked(r, s, v);
        
        // First mint should succeed
        poap.mintAttendance(eventId, attendee, nonce, deadline, signature);
        
        // Verify POAP was minted
        assertEq(poap.balanceOf(attendee), 1);
        
        // Second attempt with same signature should fail
        vm.expectRevert("Signature already used");
        poap.mintAttendance(eventId, attendee, nonce, deadline, signature);
    }

    function testCrossChainReplayPrevention() public {
        uint256 eventId = 1;
        uint256 nonce = 0;
        uint256 deadline = block.timestamp + 1800;
        
        // Generate signature for current chain
        vm.chainId(1); // Ethereum mainnet
        bytes32 digest1 = poap.getSignatureData(eventId, attendee, nonce, deadline);
        (uint8 v1, bytes32 r1, bytes32 s1) = vm.sign(signerPrivateKey, digest1);
        bytes memory signature1 = abi.encodePacked(r1, s1, v1);
        
        // Try to use same signature on different chain
        vm.chainId(137); // Polygon
        
        // Deploy POAP contract on "different chain"
        POAPAttendance poapPolygon = new POAPAttendance(address(eventFactory));
        poapPolygon.transferOwnership(signer);
        
        // Signature should be invalid on different chain
        vm.expectRevert("InvalidSignature");
        poapPolygon.mintAttendance(eventId, attendee, nonce, deadline, signature1);
    }

    function testSignatureExpiry() public {
        uint256 eventId = 1;
        uint256 nonce = 0;
        uint256 deadline = block.timestamp + 100; // Short deadline
        
        bytes32 digest = poap.getSignatureData(eventId, attendee, nonce, deadline);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPrivateKey, digest);
        bytes memory signature = abi.encodePacked(r, s, v);
        
        // Move time past deadline
        vm.warp(deadline + 1);
        
        vm.expectRevert("Signature expired");
        poap.mintAttendance(eventId, attendee, nonce, deadline, signature);
    }

    function testNonceProgression() public {
        uint256 eventId = 1;
        uint256 deadline = block.timestamp + 1800;
        
        // Try to use old nonce
        uint256 oldNonce = 0;
        bytes32 digest1 = poap.getSignatureData(eventId, attendee, oldNonce, deadline);
        (uint8 v1, bytes32 r1, bytes32 s1) = vm.sign(signerPrivateKey, digest1);
        bytes memory signature1 = abi.encodePacked(r1, s1, v1);
        
        // First mint with nonce 0
        poap.mintAttendance(eventId, attendee, oldNonce, deadline, signature1);
        
        // Try to reuse nonce 0 for different event
        vm.expectRevert("Invalid nonce");
        poap.mintAttendance(2, attendee, oldNonce, deadline + 100, signature1);
        
        // Should require nonce 1 now
        uint256 newNonce = 1;
        bytes32 digest2 = poap.getSignatureData(2, attendee, newNonce, deadline + 100);
        (uint8 v2, bytes32 r2, bytes32 s2) = vm.sign(signerPrivateKey, digest2);
        bytes memory signature2 = abi.encodePacked(r2, s2, v2);
        
        poap.mintAttendance(2, attendee, newNonce, deadline + 100, signature2);
        assertEq(poap.balanceOf(attendee), 2);
    }

    function testInvalidSigner() public {
        uint256 eventId = 1;
        uint256 nonce = 0;
        uint256 deadline = block.timestamp + 1800;
        
        // Generate signature with wrong private key
        uint256 wrongPrivateKey = 0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef;
        
        bytes32 digest = poap.getSignatureData(eventId, attendee, nonce, deadline);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(wrongPrivateKey, digest);
        bytes memory signature = abi.encodePacked(r, s, v);
        
        vm.expectRevert("InvalidSignature");
        poap.mintAttendance(eventId, attendee, nonce, deadline, signature);
    }

    function testBatchSignatureInvalidation() public {
        uint256[] memory eventIds = new uint256[](3);
        eventIds[0] = 1;
        eventIds[1] = 2;
        eventIds[2] = 3;
        
        bytes32[] memory digests = new bytes32[](3);
        uint256 deadline = block.timestamp + 1800;
        
        // Generate signatures for events
        for (uint256 i = 0; i < 3; i++) {
            digests[i] = poap.getSignatureData(eventIds[i], attendee, 0, deadline);
        }
        
        // Owner can batch invalidate signatures
        vm.startPrank(signer);
        poap.batchInvalidateSignatures(digests);
        vm.stopPrank();
        
        // All signatures should now be invalid
        for (uint256 i = 0; i < 3; i++) {
            (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPrivateKey, digests[i]);
            bytes memory signature = abi.encodePacked(r, s, v);
            
            vm.expectRevert("Signature already used");
            poap.mintAttendance(eventIds[i], attendee, 0, deadline, signature);
        }
    }
}
```

### Test Suite 3: Unbounded Loop DoS

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../contracts/core/EventFactory.sol";
import "../contracts/core/EventTicket.sol";

contract UnboundedLoopDoSTest is Test {
    EventFactory factory;
    EventTicket template;
    address organizer = makeAddr("organizer");
    address treasury = makeAddr("treasury");

    function setUp() public {
        template = new EventTicket();
        factory = new EventFactory(address(template), treasury);
        factory.verifyOrganizer(organizer);
        vm.deal(organizer, 1000 ether);
    }

    function testLargeScaleEventHandling() public {
        vm.startPrank(organizer);
        
        // Create 100 events to test scalability
        uint256[] memory eventIds = new uint256[](100);
        
        for (uint256 i = 0; i < 100; i++) {
            eventIds[i] = factory.createEvent(
                string(abi.encodePacked("Event ", vm.toString(i + 1))),
                string(abi.encodePacked("ipfs://event-", vm.toString(i + 1))),
                0.01 ether,
                100,
                block.timestamp + 3600,
                block.timestamp + 7200 + (i * 3600) // Staggered end times
            );
        }
        
        // Test pagination works efficiently with large dataset
        uint256 gasStart = gasleft();
        (uint256[] memory events, bool hasMore) = factory.getActiveEvents(0, 20);
        uint256 gasUsed = gasStart - gasleft();
        
        // Verify results
        assertEq(events.length, 20);
        assertTrue(hasMore);
        
        // Gas usage should be reasonable (less than 100k gas)
        assertLt(gasUsed, 100000, "Gas usage too high for getActiveEvents");
        
        // Test different pagination offsets
        (uint256[] memory events2,) = factory.getActiveEvents(20, 20);
        assertEq(events2.length, 20);
        
        // Verify no duplicates between pages
        for (uint256 i = 0; i < events.length; i++) {
            for (uint256 j = 0; j < events2.length; j++) {
                assertNotEq(events[i], events2[j], "Duplicate event between pages");
            }
        }
        
        vm.stopPrank();
    }

    function testTimeBasedQueries() public {
        vm.startPrank(organizer);
        
        uint256 baseTime = block.timestamp + 86400; // 1 day from now
        
        // Create events with different end times
        for (uint256 i = 0; i < 50; i++) {
            factory.createEvent(
                string(abi.encodePacked("Timed Event ", vm.toString(i + 1))),
                "ipfs://timed-test",
                0.01 ether,
                100,
                block.timestamp + 3600,
                baseTime + (i * 3600) // 1 hour apart
            );
        }
        
        // Query events ending in specific time range
        uint256 gasStart = gasleft();
        (uint256[] memory events,) = factory.getEventsEndingBetween(
            baseTime,
            baseTime + 24 * 3600, // 24 hours
            0,
            15
        );
        uint256 gasUsed = gasStart - gasleft();
        
        assertEq(events.length, 15);
        assertLt(gasUsed, 150000, "Time-based query gas usage too high");
        
        vm.stopPrank();
    }

    function testCleanupFunctionality() public {
        vm.startPrank(organizer);
        
        // Create events that will expire soon
        for (uint256 i = 0; i < 30; i++) {
            factory.createEvent(
                string(abi.encodePacked("Expiring Event ", vm.toString(i + 1))),
                "ipfs://expiring-test",
                0.01 ether,
                100,
                block.timestamp + 1800, // 30 minutes
                block.timestamp + 3600  // 1 hour (will expire)
            );
        }
        
        // Verify events are active initially
        uint256 initialActiveCount = factory.getActiveEventCount();
        assertEq(initialActiveCount, 30);
        
        // Fast forward time to expire events
        vm.warp(block.timestamp + 3700);
        
        vm.stopPrank();
        
        // Owner can cleanup expired events
        uint256 gasStart = gasleft();
        factory.cleanExpiredEvents(15); // Clean 15 events
        uint256 gasUsed = gasStart - gasleft();
        
        // Verify cleanup worked and was gas efficient
        assertLt(gasUsed, 500000, "Cleanup gas usage too high");
        
        // Verify active count decreased
        uint256 finalActiveCount = factory.getActiveEventCount();
        assertLt(finalActiveCount, initialActiveCount);
    }

    function testPaginationEdgeCases() public {
        vm.startPrank(organizer);
        
        // Create small number of events
        for (uint256 i = 0; i < 5; i++) {
            factory.createEvent(
                string(abi.encodePacked("Edge Case Event ", vm.toString(i + 1))),
                "ipfs://edge-case",
                0.01 ether,
                100,
                block.timestamp + 3600,
                block.timestamp + 7200
            );
        }
        
        // Test offset beyond available events
        (uint256[] memory events, bool hasMore) = factory.getActiveEvents(10, 5);
        assertEq(events.length, 0);
        assertFalse(hasMore);
        
        // Test limit larger than available events
        (events, hasMore) = factory.getActiveEvents(0, 100);
        assertEq(events.length, 5);
        assertFalse(hasMore);
        
        // Test exact boundary
        (events, hasMore) = factory.getActiveEvents(3, 2);
        assertEq(events.length, 2);
        assertFalse(hasMore);
        
        vm.stopPrank();
    }

    function testGasEfficiencyComparison() public {
        vm.startPrank(organizer);
        
        // Create moderate number of events
        for (uint256 i = 0; i < 200; i++) {
            factory.createEvent(
                string(abi.encodePacked("Gas Test Event ", vm.toString(i + 1))),
                "ipfs://gas-test",
                0.01 ether,
                100,
                block.timestamp + 3600,
                block.timestamp + 7200 + (i % 24) * 3600 // Mix of end times
            );
        }
        
        // Test multiple query scenarios
        struct GasTest {
            uint256 offset;
            uint256 limit;
            uint256 maxGas;
        }
        
        GasTest[4] memory tests = [
            GasTest(0, 10, 50000),     // First page, small limit
            GasTest(50, 25, 80000),    // Middle page, medium limit  
            GasTest(150, 50, 120000),  // Later page, large limit
            GasTest(0, 100, 150000)    // Large first page
        ];
        
        for (uint256 i = 0; i < tests.length; i++) {
            uint256 gasStart = gasleft();
            (uint256[] memory events, bool hasMore) = factory.getActiveEvents(
                tests[i].offset, 
                tests[i].limit
            );
            uint256 gasUsed = gasStart - gasleft();
            
            assertLt(gasUsed, tests[i].maxGas, 
                string(abi.encodePacked("Gas test ", vm.toString(i + 1), " failed")));
            
            // Verify results are reasonable
            assertLe(events.length, tests[i].limit);
            if (events.length == tests[i].limit && tests[i].offset + tests[i].limit < 200) {
                assertTrue(hasMore, "Should have more events");
            }
        }
        
        vm.stopPrank();
    }

    function testConcurrentActiveEventModifications() public {
        vm.startPrank(organizer);
        
        // Create events
        uint256[] memory eventIds = new uint256[](20);
        for (uint256 i = 0; i < 20; i++) {
            eventIds[i] = factory.createEvent(
                string(abi.encodePacked("Concurrent Event ", vm.toString(i + 1))),
                "ipfs://concurrent-test",
                0.01 ether,
                100,
                block.timestamp + 3600,
                block.timestamp + 7200
            );
        }
        
        // Deactivate some events
        for (uint256 i = 0; i < 10; i += 2) {
            factory.setEventStatus(eventIds[i], false);
        }
        
        // Query active events - should only return active ones
        (uint256[] memory activeEvents,) = factory.getActiveEvents(0, 100);
        
        // Verify only active events returned
        for (uint256 i = 0; i < activeEvents.length; i++) {
            EventFactory.Event memory eventData = factory.getEvent(activeEvents[i]);
            assertTrue(eventData.isActive, "Inactive event returned in active query");
        }
        
        // Should have 15 active events (20 - 5 deactivated)
        assertEq(activeEvents.length, 15);
        
        vm.stopPrank();
    }
}
```

## Attack Vector Simulation Tests

### Front-Running Attack Tests

```solidity
contract FrontRunningAttackTest is Test {
    EventFactory factory;
    EventTicket template;
    address victim = makeAddr("victim");
    address attacker = makeAddr("attacker");
    address treasury = makeAddr("treasury");

    function setUp() public {
        template = new EventTicket();
        factory = new EventFactory(address(template), treasury);
        factory.verifyOrganizer(victim);
        factory.verifyOrganizer(attacker);
        
        vm.deal(victim, 100 ether);
        vm.deal(attacker, 100 ether);
    }

    function testCannotFrontRunEventCreation() public {
        // Victim starts creating event
        vm.startPrank(victim);
        
        // Attacker sees transaction in mempool and tries to front-run
        // This should not be possible with CREATE2 implementation
        
        uint256 victimEventId = factory.createEvent(
            "Victim Event",
            "ipfs://victim-event",
            0.1 ether,
            100,
            block.timestamp + 3600,
            block.timestamp + 7200
        );
        
        // Verify victim owns the event
        EventFactory.Event memory eventData = factory.getEvent(victimEventId);
        assertEq(eventData.organizer, victim);
        
        EventTicket ticketContract = EventTicket(eventData.ticketContract);
        assertEq(ticketContract.organizer(), victim);
        assertEq(ticketContract.owner(), victim);
        
        vm.stopPrank();
        
        // Attacker cannot gain control of the ticket contract
        vm.startPrank(attacker);
        
        // Any attempt to interfere should fail
        vm.expectRevert();
        ticketContract.mintTicket{value: 0.1 ether}(attacker, 1, 1);
        
        vm.stopPrank();
    }
}
```

### MEV Attack Tests

```solidity
contract MEVAttackTest is Test {
    EventFactory factory;
    EventTicket template;
    address organizer = makeAddr("organizer");
    address buyer = makeAddr("buyer");
    address mevBot = makeAddr("mevBot");
    address treasury = makeAddr("treasury");

    function setUp() public {
        template = new EventTicket();
        factory = new EventFactory(address(template), treasury);
        factory.verifyOrganizer(organizer);
        
        vm.deal(organizer, 100 ether);
        vm.deal(buyer, 100 ether);
        vm.deal(mevBot, 100 ether);
    }

    function testMEVProtection() public {
        // Create event
        vm.startPrank(organizer);
        uint256 eventId = factory.createEvent(
            "MEV Test Event",
            "ipfs://mev-test",
            0.1 ether,
            100,
            block.timestamp + 3600,
            block.timestamp + 7200
        );
        vm.stopPrank();
        
        EventFactory.Event memory eventData = factory.getEvent(eventId);
        EventTicket ticketContract = EventTicket(eventData.ticketContract);
        
        // MEV bot tries to sandwich attack ticket purchase
        vm.startPrank(mevBot);
        
        // Bot tries to buy ticket first (front-run)
        ticketContract.mintTicket{value: 0.1 ether}(mevBot, 1, 1);
        
        vm.stopPrank();
        
        // Regular user tries to buy ticket
        vm.startPrank(buyer);
        
        // Should still be able to buy ticket (no MEV exploitation)
        ticketContract.mintTicket{value: 0.1 ether}(buyer, 2, 1);
        
        // Verify both have tickets
        assertEq(ticketContract.balanceOf(mevBot), 1);
        assertEq(ticketContract.balanceOf(buyer), 1);
        
        vm.stopPrank();
    }
}
```

## Performance and Gas Optimization Tests

### Gas Limit DoS Tests

```solidity
contract GasLimitDoSTest is Test {
    EventFactory factory;
    EventTicket template;
    address organizer = makeAddr("organizer");
    address treasury = makeAddr("treasury");

    function setUp() public {
        template = new EventTicket();
        factory = new EventFactory(address(template), treasury);
        factory.verifyOrganizer(organizer);
        vm.deal(organizer, 10000 ether);
    }

    function testGasLimitResistance() public {
        vm.startPrank(organizer);
        
        // Create maximum reasonable number of events
        uint256 maxEvents = 1000;
        
        for (uint256 i = 0; i < maxEvents; i++) {
            if (gasleft() < 200000) break; // Prevent out of gas
            
            factory.createEvent(
                string(abi.encodePacked("Stress Test Event ", vm.toString(i + 1))),
                "ipfs://stress-test",
                0.001 ether,
                10,
                block.timestamp + 3600,
                block.timestamp + 7200 + (i % 100) * 3600
            );
        }
        
        uint256 createdEvents = factory.eventCount();
        console.log("Created events:", createdEvents);
        
        // Test that queries still work with large number of events
        uint256 gasStart = gasleft();
        (uint256[] memory events, bool hasMore) = factory.getActiveEvents(0, 50);
        uint256 gasUsed = gasStart - gasleft();
        
        assertEq(events.length, 50);
        assertTrue(hasMore);
        assertLt(gasUsed, 200000, "Query gas usage acceptable even with many events");
        
        vm.stopPrank();
    }

    function testBatchOperationGasEfficiency() public {
        vm.startPrank(organizer);
        
        // Test batch event creation
        string[] memory names = new string[](10);
        string[] memory uris = new string[](10);
        uint256[] memory prices = new uint256[](10);
        uint256[] memory supplies = new uint256[](10);
        uint256[] memory startTimes = new uint256[](10);
        uint256[] memory endTimes = new uint256[](10);
        
        for (uint256 i = 0; i < 10; i++) {
            names[i] = string(abi.encodePacked("Batch Event ", vm.toString(i + 1)));
            uris[i] = "ipfs://batch-test";
            prices[i] = 0.01 ether;
            supplies[i] = 100;
            startTimes[i] = block.timestamp + 3600;
            endTimes[i] = block.timestamp + 7200;
        }
        
        uint256 gasStart = gasleft();
        uint256[] memory eventIds = factory.createEventsBlizzard(
            names, uris, prices, supplies, startTimes, endTimes
        );
        uint256 gasUsed = gasStart - gasleft();
        
        assertEq(eventIds.length, 10);
        
        // Batch creation should be more efficient than individual calls
        uint256 avgGasPerEvent = gasUsed / 10;
        assertLt(avgGasPerEvent, 200000, "Batch creation should be gas efficient");
        
        vm.stopPrank();
    }
}
```

## Test Execution Framework

### Automated Test Runner

```typescript
// test-runner.ts
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

interface TestSuite {
  name: string;
  command: string;
  critical: boolean;
}

class SecurityTestRunner {
  private testSuites: TestSuite[] = [
    {
      name: "Critical Vulnerability Tests",
      command: "forge test --match-contract 'CloneRaceCondition|SignatureReplay|UnboundedLoopDoS'",
      critical: true
    },
    {
      name: "Attack Vector Tests", 
      command: "forge test --match-contract 'FrontRunning|MEV|GasLimitDoS'",
      critical: true
    },
    {
      name: "Integration Security Tests",
      command: "npx hardhat test test/integration/security/*.ts",
      critical: false
    },
    {
      name: "Fuzz Tests",
      command: "echidna-test contracts/test/EchidnaSecurity.sol",
      critical: false
    }
  ];

  async runAllTests(): Promise<void> {
    console.log("🔒 Starting Comprehensive Security Test Suite");
    console.log("=" .repeat(60));
    
    let criticalFailures = 0;
    let totalFailures = 0;
    
    for (const suite of this.testSuites) {
      console.log(`\n🧪 Running: ${suite.name}`);
      console.log("-".repeat(40));
      
      try {
        const { stdout, stderr } = await execAsync(suite.command);
        console.log("✅ PASSED");
        if (stdout) console.log(stdout);
      } catch (error: any) {
        console.log("❌ FAILED");
        console.error(error.stdout || error.message);
        
        totalFailures++;
        if (suite.critical) {
          criticalFailures++;
        }
      }
    }
    
    console.log("\n" + "=".repeat(60));
    console.log("📊 Test Results Summary:");
    console.log(`Total Test Suites: ${this.testSuites.length}`);
    console.log(`Failed Suites: ${totalFailures}`);
    console.log(`Critical Failures: ${criticalFailures}`);
    
    if (criticalFailures > 0) {
      console.log("\n🚨 CRITICAL FAILURES DETECTED!");
      console.log("❌ System is NOT READY for deployment");
      process.exit(1);
    } else if (totalFailures > 0) {
      console.log("\n⚠️  Some non-critical tests failed");
      console.log("⚠️  Review failures before deployment");
      process.exit(1);
    } else {
      console.log("\n✅ All security tests passed!");
      console.log("✅ System ready for next phase");
    }
  }
}

// Run if called directly
if (require.main === module) {
  const runner = new SecurityTestRunner();
  runner.runAllTests().catch(console.error);
}

export { SecurityTestRunner };
```

### Continuous Security Testing

```yaml
# .github/workflows/security-tests.yml
name: Security Test Suite

on:
  push:
    branches: [ main, develop, security-fixes ]
  pull_request:
    branches: [ main ]

jobs:
  security-tests:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: |
        npm ci
        npm install -g @foundry-rs/forge
        
    - name: Compile contracts
      run: forge build
      
    - name: Run critical vulnerability tests
      run: |
        forge test --match-contract "CloneRaceCondition|SignatureReplay|UnboundedLoopDoS" -vvv
        
    - name: Run attack vector tests
      run: |
        forge test --match-contract "FrontRunning|MEV|GasLimitDoS" -vvv
        
    - name: Run integration tests
      run: |
        npx hardhat test test/integration/security/
        
    - name: Generate test coverage
      run: |
        forge coverage --report lcov
        
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./lcov.info
        
    - name: Security test report
      run: |
        npm run test:security:report
```

## Test Reporting and Metrics

### Security Test Metrics

```typescript
// security-metrics.ts
interface SecurityMetrics {
  totalTests: number;
  passedTests: number;
  criticalTests: number;
  criticalPassed: number;
  coverage: number;
  gasEfficiencyScore: number;
  vulnerabilitiesFixed: number;
  vulnerabilitiesRemaining: number;
}

class SecurityReporter {
  generateReport(metrics: SecurityMetrics): string {
    const passRate = (metrics.passedTests / metrics.totalTests) * 100;
    const criticalPassRate = (metrics.criticalPassed / metrics.criticalTests) * 100;
    
    return `
# Security Test Report

## Overall Status
- **Security Level**: ${this.getSecurityLevel(criticalPassRate)}
- **Deployment Ready**: ${criticalPassRate === 100 ? '✅ YES' : '❌ NO'}

## Test Results
- **Total Tests**: ${metrics.totalTests}
- **Passed**: ${metrics.passedTests} (${passRate.toFixed(1)}%)
- **Critical Tests**: ${metrics.criticalTests}
- **Critical Passed**: ${metrics.criticalPassed} (${criticalPassRate.toFixed(1)}%)

## Code Quality
- **Test Coverage**: ${metrics.coverage.toFixed(1)}%
- **Gas Efficiency Score**: ${metrics.gasEfficiencyScore}/100

## Vulnerability Status
- **Fixed**: ${metrics.vulnerabilitiesFixed}
- **Remaining**: ${metrics.vulnerabilitiesRemaining}

## Recommendations
${this.getRecommendations(metrics)}
    `;
  }
  
  private getSecurityLevel(criticalPassRate: number): string {
    if (criticalPassRate === 100) return "🟢 HIGH";
    if (criticalPassRate >= 80) return "🟡 MEDIUM";
    return "🔴 LOW";
  }
  
  private getRecommendations(metrics: SecurityMetrics): string {
    const recommendations = [];
    
    if (metrics.criticalPassed < metrics.criticalTests) {
      recommendations.push("- ❌ Fix all critical vulnerabilities before proceeding");
    }
    
    if (metrics.coverage < 95) {
      recommendations.push("- ⚠️ Increase test coverage to >95%");
    }
    
    if (metrics.gasEfficiencyScore < 80) {
      recommendations.push("- ⚠️ Optimize gas usage for better efficiency");
    }
    
    if (recommendations.length === 0) {
      recommendations.push("- ✅ All security requirements met");
      recommendations.push("- ✅ Ready for external security audit");
    }
    
    return recommendations.join('\n');
  }
}
```

---

**🔒 TESTING PRIORITY**: All critical vulnerability tests must pass before proceeding with any deployment activities.

**Test Execution Time**: ~2-4 hours for complete suite  
**Required Coverage**: >95% for critical paths  
**Success Criteria**: 100% critical tests passing, 0 high-severity findings

**Next Phase**: After all tests pass, proceed to external security audit and bug bounty program.
